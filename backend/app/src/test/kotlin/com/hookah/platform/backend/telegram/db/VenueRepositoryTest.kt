package com.hookah.platform.backend.telegram.db

import com.hookah.platform.backend.miniapp.venue.VenueStatus
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource
import java.sql.Connection
import java.sql.SQLException
import javax.sql.DataSource
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

class VenueRepositoryTest {
    companion object {
        private lateinit var dataSource: HikariDataSource
        private var venueIdOne: Long = 0
        private var venueIdTwo: Long = 0

        @BeforeAll
        @JvmStatic
        fun setup() {
            dataSource = HikariDataSource(
                HikariConfig().apply {
                    driverClassName = "org.h2.Driver"
                    jdbcUrl = "jdbc:h2:mem:venue_repo;MODE=PostgreSQL;DATABASE_TO_UPPER=false;DB_CLOSE_DELAY=-1;INIT=CREATE DOMAIN IF NOT EXISTS TIMESTAMPTZ AS TIMESTAMP WITH TIME ZONE\\;CREATE DOMAIN IF NOT EXISTS JSONB AS JSON"
                    maximumPoolSize = 5
                }
            )
            createSchema(dataSource)
            seedData()
        }

        @AfterAll
        @JvmStatic
        fun tearDown() {
            dataSource.close()
        }

        private fun seedData() {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "INSERT INTO users (telegram_user_id, username) VALUES (1001, 'owner')"
                ).executeUpdate()
                venueIdOne = insertVenue(connection, "First Venue")
                venueIdTwo = insertVenue(connection, "Second Venue")
            }
        }

        private fun insertVenue(connection: Connection, name: String): Long {
            return connection.prepareStatement(
                """
                    INSERT INTO venues (name, status)
                    VALUES (?, ?)
                """.trimIndent(),
                java.sql.Statement.RETURN_GENERATED_KEYS
            ).use { statement ->
                statement.setString(1, name)
                statement.setString(2, VenueStatus.PUBLISHED.dbValue)
                statement.executeUpdate()
                statement.generatedKeys.use { rs ->
                    rs.next()
                    rs.getLong(1)
                }
            }
        }

        private fun createSchema(dataSource: DataSource) {
            dataSource.connection.use { connection ->
                connection.createStatement().use { statement ->
                    statement.execute(
                        """
                            CREATE TABLE IF NOT EXISTS users (
                                telegram_user_id BIGINT PRIMARY KEY,
                                username TEXT NULL,
                                first_name TEXT NULL,
                                last_name TEXT NULL,
                                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                                updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                            )
                        """.trimIndent()
                    )
                    statement.execute(
                        """
                            CREATE TABLE IF NOT EXISTS venues (
                                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                name TEXT NOT NULL,
                                city TEXT NULL,
                                address TEXT NULL,
                                status TEXT NOT NULL,
                                features JSONB NULL,
                                ui_layout JSONB NULL,
                                staff_chat_id BIGINT NULL,
                                staff_chat_linked_at TIMESTAMP WITH TIME ZONE NULL,
                                staff_chat_linked_by_user_id BIGINT NULL,
                                staff_chat_unlinked_at TIMESTAMP WITH TIME ZONE NULL,
                                staff_chat_unlinked_by_user_id BIGINT NULL,
                                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                                updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                            )
                        """.trimIndent()
                    )
                    statement.execute(
                        "CREATE UNIQUE INDEX IF NOT EXISTS uq_venues_staff_chat ON venues(staff_chat_id)"
                    )
                }
            }
        }
    }

    @BeforeEach
    fun cleanup() {
        dataSource.connection.use { connection ->
            connection.prepareStatement(
                "UPDATE venues SET staff_chat_id = NULL, staff_chat_linked_at = NULL, staff_chat_linked_by_user_id = NULL"
            ).executeUpdate()
        }
    }

    @Test
    fun `bindStaffChat maps unique violation to friendly result`() = runBlocking {
        val repository = object : VenueRepository(dataSource) {
            private var skipLookup = true
            override fun findVenueIdByChatId(connection: Connection, chatId: Long): Long? {
                return if (skipLookup) {
                    skipLookup = false
                    null
                } else {
                    super.findVenueIdByChatId(connection, chatId)
                }
            }
        }
        dataSource.connection.use { connection ->
            connection.prepareStatement("UPDATE venues SET staff_chat_id = ? WHERE id = ?")
                .use { statement ->
                    statement.setLong(1, -500)
                    statement.setLong(2, venueIdOne)
                    statement.executeUpdate()
                }
        }

        val result = repository.bindStaffChat(venueIdTwo, -500, 1001)

        assertTrue(result is BindResult.ChatAlreadyLinked) { "result=$result" }
    }

    @Test
    fun `hasSqlState detects nested SQLException`() {
        val nested = RuntimeException(SQLException("duplicate", "23505"))
        assertTrue(nested.hasSqlState("23505"))
        assertFalse(RuntimeException(SQLException("fk", "23503")).hasSqlState("23505"))
    }

    @Test
    fun `hasSqlState scans nextException chain`() {
        val sqlException = SQLException("root", "22000")
        sqlException.setNextException(SQLException("duplicate", "23505"))
        val wrapped = RuntimeException(sqlException)
        assertTrue(wrapped.hasSqlState("23505"))
    }

    @Test
    fun `hasSqlState inspects suppressed exceptions`() {
        val parent = RuntimeException(SQLException("root", "22000"))
        parent.addSuppressed(SQLException("duplicate", "23505"))
        assertTrue(parent.hasSqlState("23505"))
    }
}
